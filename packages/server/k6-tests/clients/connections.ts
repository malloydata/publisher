/**
 * Automatically generated by @grafana/openapi-to-k6: 0.3.2
 * Do not edit manually.
 * Malloy Publisher - Semantic Model Serving API
 * The Malloy Publisher - Semantic Model Serving API provides comprehensive access to Malloy packages and their associated resources.
A Malloy package is a directory containing Malloy models (.malloy files), Malloy notebooks (.malloynb files), and embedded databases
(.parquet files) with a malloy-publisher.json manifest at the package's root directory.

## Key Features

- **Project Management**: Create and manage projects with their associated packages and connections
- **Package Lifecycle**: Full CRUD operations for Malloy packages and their versions
- **Model & Notebook Access**: Retrieve and execute Malloy models and notebooks
- **Connection Management**: Secure database connection configuration and testing
- **Query Execution**: Execute queries against models and retrieve results
- **Watch Mode**: Real-time file watching for development workflows

## Resource Hierarchy

The API follows a hierarchical resource structure:
```
Projects
├── Connections
└── Packages
    ├── Models
    ├── Notebooks
    └── Databases
```

For examples, see the Malloy samples packages (https://github.com/malloydata/malloy-samples) repository.

 * Service version: v0
 */
import { URL, URLSearchParams } from "https://jslib.k6.io/url/1.0.0/index.js";

import * as http from "k6/http";
import type { Params, Response } from "k6/http";

import type {
   Connection,
   CreateConnection201,
   DeleteConnection200,
   GetQuerydataParams,
   GetSqlsourceParams,
   GetTablesourceParams,
   GetTemporarytableParams,
   IdentifierPattern,
   PathPattern,
   PostQuerydataBody,
   PostQuerydataParams,
   PostSqlsourceBody,
   PostTemporarytableBody,
   QueryData,
   Schema,
   SqlSource,
   Table,
   TableSource,
   TemporaryTable,
   UpdateConnection200,
   UpdateConnectionBody,
} from "./malloyPublisherSemanticModelServingAPI.schemas";

/**
 * This is the base client to use for interacting with the API.
 */
export class ConnectionsClient {
   private cleanBaseUrl: string;
   private commonRequestParameters: Params;

   constructor(clientOptions: {
      baseUrl: string;
      commonRequestParameters?: Params;
   }) {
      this.cleanBaseUrl = clientOptions.baseUrl.replace(/\/+$/, "");

      this.commonRequestParameters =
         clientOptions.commonRequestParameters || {};
   }

   /**
 * Retrieves a list of all database connections configured for the specified project.
Each connection includes its configuration, type, and status information. This endpoint
is useful for discovering available data sources within a project.

 * @summary List project database connections
 */
   listConnections(
      projectName: IdentifierPattern,
      requestParameters?: Params,
   ): {
      response: Response;
      data: Connection[];
   } {
      const url = new URL(
         this.cleanBaseUrl + `/projects/${projectName}/connections`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "GET",
         url.toString(),
         undefined,
         mergedRequestParameters,
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Retrieves detailed information about a specific database connection within a project.
This includes connection configuration, credentials (if accessible), and metadata.
Useful for inspecting connection settings and troubleshooting connectivity issues.

 * @summary Get connection details
 */
   getConnection(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      requestParameters?: Params,
   ): {
      response: Response;
      data: Connection;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "GET",
         url.toString(),
         undefined,
         mergedRequestParameters,
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Creates a new database connection in the specified project.

 * @summary Create a new database connection
 */
   createConnection(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      connection: Connection,
      requestParameters?: Params,
   ): {
      response: Response;
      data: CreateConnection201;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "POST",
         url.toString(),
         JSON.stringify(connection),
         {
            ...mergedRequestParameters,
            headers: {
               ...mergedRequestParameters?.headers,
               "Content-Type": "application/json",
            },
         },
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Updates the configuration of an existing database connection.

 * @summary Update an existing database connection
 */
   updateConnection(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      updateConnectionBody: UpdateConnectionBody,
      requestParameters?: Params,
   ): {
      response: Response;
      data: UpdateConnection200;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "PATCH",
         url.toString(),
         JSON.stringify(updateConnectionBody),
         {
            ...mergedRequestParameters,
            headers: {
               ...mergedRequestParameters?.headers,
               "Content-Type": "application/json",
            },
         },
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Permanently deletes a database connection from the project.

 * @summary Delete a database connection
 */
   deleteConnection(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      requestParameters?: Params,
   ): {
      response: Response;
      data: DeleteConnection200;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "DELETE",
         url.toString(),
         undefined,
         mergedRequestParameters,
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Retrieves a list of all schemas (databases) available in the specified connection.
Each schema includes metadata such as name, description, and whether it's the default schema.
This endpoint is useful for exploring the database structure and discovering available data sources.

 * @summary List database schemas
 */
   listSchemas(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      requestParameters?: Params,
   ): {
      response: Response;
      data: Schema[];
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/schemas`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "GET",
         url.toString(),
         undefined,
         mergedRequestParameters,
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Retrieves a list of all tables and views available in the specified database schema.
This endpoint is useful for discovering available data sources and exploring the database
structure. The schema must exist in the connection for this operation to succeed.

 * @summary List tables in database
 */
   listTables(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      schemaName: IdentifierPattern,
      requestParameters?: Params,
   ): {
      response: Response;
      data: Table[];
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/schemas/${schemaName}/tables`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "GET",
         url.toString(),
         undefined,
         mergedRequestParameters,
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Retrieves a table from the specified database schema.
This endpoint is useful for discovering available data sources and exploring the database
structure. The schema must exist in the connection for this operation to succeed.
The tablePath is the full path to the table, including the schema name.

 * @summary Get table details from database
 */
   getTable(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      schemaName: IdentifierPattern,
      tablePath: PathPattern,
      requestParameters?: Params,
   ): {
      response: Response;
      data: Table;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/schemas/${schemaName}/tables/${tablePath}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "GET",
         url.toString(),
         undefined,
         mergedRequestParameters,
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions.
Use the POST version instead for better security and functionality.

Creates a Malloy source from a SQL statement using the specified connection.
The SQL statement is executed to generate a source definition that can be used in Malloy models.

 * @deprecated
 * @summary Get SQL source (deprecated)
 */
   getSqlsource(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      params?: GetSqlsourceParams,
      requestParameters?: Params,
   ): {
      response: Response;
      data: SqlSource;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/sqlSource` +
            `?${new URLSearchParams(params).toString()}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request("GET", url.toString(), undefined, {
         ...mergedRequestParameters,
      });
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Creates a Malloy source from a SQL statement using the specified database connection.
The SQL statement is executed to generate a source definition that can be used in Malloy models.

 * @summary Create SQL source from statement
 */
   postSqlsource(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      postSqlsourceBody: PostSqlsourceBody,
      requestParameters?: Params,
   ): {
      response: Response;
      data: SqlSource;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/sqlSource`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "POST",
         url.toString(),
         JSON.stringify(postSqlsourceBody),
         {
            ...mergedRequestParameters,
            headers: {
               ...mergedRequestParameters?.headers,
               "Content-Type": "application/json",
            },
         },
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Executes a SQL statement against the specified database connection and returns the results.
The results include data, metadata, and execution information.

 * @summary Execute SQL query
 */
   postQuerydata(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      postQuerydataBody: PostQuerydataBody,
      params?: PostQuerydataParams,
      requestParameters?: Params,
   ): {
      response: Response;
      data: QueryData;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/sqlQuery` +
            `?${new URLSearchParams(params).toString()}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "POST",
         url.toString(),
         JSON.stringify(postQuerydataBody),
         {
            ...mergedRequestParameters,
            headers: {
               ...mergedRequestParameters?.headers,
               "Content-Type": "application/json",
            },
         },
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Creates a temporary table from a SQL statement using the specified database connection.
Temporary tables are useful for storing intermediate results during complex queries and data processing workflows.

 * @summary Create temporary table
 */
   postTemporarytable(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      postTemporarytableBody: PostTemporarytableBody,
      requestParameters?: Params,
   ): {
      response: Response;
      data: TemporaryTable;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/sqlTemporaryTable`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request(
         "POST",
         url.toString(),
         JSON.stringify(postTemporarytableBody),
         {
            ...mergedRequestParameters,
            headers: {
               ...mergedRequestParameters?.headers,
               "Content-Type": "application/json",
            },
         },
      );
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions.
Use the POST version instead for better security and functionality.

Creates a temporary table from a SQL statement using the specified connection.
Temporary tables are useful for storing intermediate results during complex queries.

 * @deprecated
 * @summary Create temporary table (deprecated)
 */
   getTemporarytable(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      params?: GetTemporarytableParams,
      requestParameters?: Params,
   ): {
      response: Response;
      data: TemporaryTable;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/temporaryTable` +
            `?${new URLSearchParams(params).toString()}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request("GET", url.toString(), undefined, {
         ...mergedRequestParameters,
      });
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * Retrieves information about a specific table or view from the database connection.
This includes table schema, column definitions, and metadata. The table can be specified
by either tableKey or tablePath parameters, depending on the database type.

 * @deprecated
 * @summary Get table source information
 */
   getTablesource(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      params?: GetTablesourceParams,
      requestParameters?: Params,
   ): {
      response: Response;
      data: TableSource;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/tableSource` +
            `?${new URLSearchParams(params).toString()}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request("GET", url.toString(), undefined, {
         ...mergedRequestParameters,
      });
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }
   /**
 * **DEPRECATED**: This endpoint is deprecated and may be removed in future versions.
Use the POST version instead for better security and functionality.

Executes a SQL statement against the specified database connection and returns the results.
The query results include data, metadata, and execution information.

 * @deprecated
 * @summary Execute SQL query (deprecated)
 */
   getQuerydata(
      projectName: IdentifierPattern,
      connectionName: IdentifierPattern,
      params?: GetQuerydataParams,
      requestParameters?: Params,
   ): {
      response: Response;
      data: QueryData;
   } {
      const url = new URL(
         this.cleanBaseUrl +
            `/projects/${projectName}/connections/${connectionName}/queryData` +
            `?${new URLSearchParams(params).toString()}`,
      );
      const mergedRequestParameters = this._mergeRequestParameters(
         requestParameters || {},
         this.commonRequestParameters,
      );
      const response = http.request("GET", url.toString(), undefined, {
         ...mergedRequestParameters,
      });
      let data;

      try {
         data = response.json();
      } catch {
         data = response.body;
      }
      return {
         response,
         data,
      };
   }

   /**
    * Merges the provided request parameters with default parameters for the client.
    *
    * @param {Params} requestParameters - The parameters provided specifically for the request
    * @param {Params} commonRequestParameters - Common parameters for all requests
    * @returns {Params} - The merged parameters
    */
   private _mergeRequestParameters(
      requestParameters?: Params,
      commonRequestParameters?: Params,
   ): Params {
      return {
         ...commonRequestParameters, // Default to common parameters
         ...requestParameters, // Override with request-specific parameters
         headers: {
            ...(commonRequestParameters?.headers || {}), // Ensure headers are defined
            ...(requestParameters?.headers || {}),
         },
         cookies: {
            ...(commonRequestParameters?.cookies || {}), // Ensure cookies are defined
            ...(requestParameters?.cookies || {}),
         },
         tags: {
            ...(commonRequestParameters?.tags || {}), // Ensure tags are defined
            ...(requestParameters?.tags || {}),
         },
      };
   }
}
